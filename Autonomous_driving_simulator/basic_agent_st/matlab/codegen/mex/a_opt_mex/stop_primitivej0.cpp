//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// stop_primitivej0.cpp
//
// Code generation for function 'stop_primitivej0'
//

// Include files
#include "stop_primitivej0.h"
#include "a_opt_mex_data.h"
#include "evalPrimitiveCoeffs.h"
#include "rt_nonfinite.h"

// Function Definitions
void stop_primitivej0(const emlrtStack *, real_T v0, real_T a0, real_T m[6],
                      real_T *T, real_T *smax)
{
  covrtLogFcn(&emlrtCoverageInstance, 11, 0);
  //  Stopping primitive algorithm with j0 = 0
  if (covrtLogCond(&emlrtCoverageInstance, 11, 0, 0, v0 > 0.0) &&
      covrtLogCond(&emlrtCoverageInstance, 11, 0, 1, a0 < 0.0)) {
    covrtLogMcdc(&emlrtCoverageInstance, 11, 0, 0, true);
    covrtLogIf(&emlrtCoverageInstance, 11, 0, 0, true);
    covrtLogBasicBlock(&emlrtCoverageInstance, 11, 0);
    covrtLogFcn(&emlrtCoverageInstance, 12, 0);
    covrtLogBasicBlock(&emlrtCoverageInstance, 12, 0);
    // finalOptTimeStopj0
    //     OUT1 = finalOptTimeStopj0(V0,A0)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:44
    *T = v0 * -2.0 / a0;
    covrtLogFcn(&emlrtCoverageInstance, 13, 0);
    covrtLogBasicBlock(&emlrtCoverageInstance, 13, 0);
    // finalOptPosj0
    //     SF_J0 = finalOptPosj0(V0,A0,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:44
    *smax = *T * (v0 * 4.0 + *T * a0) * 0.15;
    evalPrimitiveCoeffs(v0, a0, *smax, 0.0, *T, m);
  } else {
    covrtLogMcdc(&emlrtCoverageInstance, 11, 0, 0, false);
    covrtLogIf(&emlrtCoverageInstance, 11, 0, 0, false);
    covrtLogBasicBlock(&emlrtCoverageInstance, 11, 1);
    *T = 0.0;
    *smax = 0.0;
    for (int32_T i{0}; i < 6; i++) {
      m[i] = 0.0;
    }
  }
}

// End of code generation (stop_primitivej0.cpp)
